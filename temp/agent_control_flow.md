# Agent Control Flow в Computer Use Demo

## Текущая реализация управления агентами

### Основные компоненты системы

1. **ManagerAgent** - центральный агент, координирующий работу
   - Ведет список специалистов (`self.specialists`)
   - Отслеживает активного агента (`self.active_agent_id`)
   - Имеет методы `get_active_agent()` и `set_active_agent()`

2. **SpecialistAgent** - выполняет конкретные задачи
   - Имеет ссылку на `manager_agent`
   - Может возвращать управление менеджеру через инструмент `return_to_manager`

3. **ReturnToManagerTool** - инструмент для возврата управления менеджеру
   - Переключает активного агента на менеджера через `manager_agent.set_active_agent("manager")`
   - Не запускает менеджера после переключения

4. **Streamlit интерфейс** - контролирует UI и запуск агентов
   - Обрабатывает сообщения пользователя и маршрутизирует через `manager_agent.handle_user_message()`
   - Запускает агента через `active_agent.run()`

### Текущий поток выполнения

1. Пользователь отправляет сообщение в интерфейсе
2. Интерфейс вызывает `manager_agent.handle_user_message(message)`
3. Менеджер перенаправляет сообщение активному агенту
4. После обработки сообщения интерфейс запускает активного агента через `active_agent.run()`
5. Когда менеджер делегирует задачу специалисту через вызов `agent` инструмента:
   - Создается специалист и регистрируется у менеджера
   - Менеджер переключает активного агента на этого специалиста
   - Вызов `specialist_agent.run()` блокирует выполнение метода `agent` инструмента
   - Только после завершения работы специалиста метод `agent` возвращает результат
6. Когда специалист выполняет `return_to_manager`:
   - Active agent переключается на менеджера
   - Но менеджер НЕ запускается автоматически - мы просто меняем указатель
   - Цикл `run()` специалиста продолжает выполняться
   - Менеджер будет запущен только при следующем сообщении пользователя

## Проблема

Когда специалист вызывает инструмент `return_to_manager`, управление действительно переключается на менеджера (`manager_agent.set_active_agent("manager")`), но менеджер не запускается автоматически. Это происходит потому, что:

1. Инструмент `return_to_manager` только меняет `active_agent_id` в объекте менеджера
2. Цикл выполнения специалиста продолжается и не прерывается
3. Нет кода, который бы автоматически запускал менеджера после переключения
4. Менеджер запустится только при следующем сообщении пользователя

## Варианты решения

Проанализировав текущую реализацию и поток выполнения, мы рассмотрели несколько подходов:

### Вариант 1: Запуск менеджера с помощью await в `ReturnToManagerTool`

```python
async def _call(self, summary: str, completed: bool) -> ToolResult:
    # ... существующий код ...
    self.manager_agent.set_active_agent("manager")
    
    # Добавляем сообщение в историю менеджера
    manager_message = {...}
    self.manager_agent.history.append(manager_message)
    
    # Запускаем менеджера и ждем завершения
    await self.manager_agent.run(...)
    
    return ToolResult(...)
```

**Проблема**: Блокирует выполнение специалиста до завершения работы менеджера, создает вложенные циклы ожидания.

### Вариант 2: Асинхронный запуск без ожидания (fire-and-forget)

```python
async def _call(self, summary: str, completed: bool) -> ToolResult:
    # ... существующий код ...
    self.manager_agent.set_active_agent("manager")
    
    # Добавляем сообщение в историю менеджера
    manager_message = {...}
    self.manager_agent.history.append(manager_message)
    
    # Запускаем менеджера без ожидания
    asyncio.create_task(self.manager_agent.run(...))
    
    return ToolResult(...)
```

**Проблема**: Создаёт параллельное асинхронное выполнение без явного управления жизненным циклом.

### Вариант 3: Модификация метода Agent.run() (рекомендуемый)

Этот подход использует естественный поток работы системы и блокирующую модель, которая уже используется при запуске специалистов из менеджера.

```python
# В методе Agent.run()
for content_block in response_params:
    # ...существующий код...
    
    if content_block["type"] == "tool_use" and content_block["name"] == "return_to_manager":
        # Выполнить инструмент
        result = await tool_collection.run(...)
        tool_result_content.append(make_api_tool_result(result, content_block["id"]))
        
        # Добавляем результаты в историю
        self.history.append({"content": tool_result_content, "role": "user"})
        
        # Выходим из цикла досрочно - контроль вернется в AgentTool
        logger.debug(f"Agent '{self.agent_id}' returning control via return_to_manager")
        return self.history.messages
```

А затем в `AgentTool20250124._call()` после выполнения специалиста добавить запуск менеджера:

```python
# Запускаем специалиста
result_messages = await specialist_agent.run(...)

# Если active_agent_id изменился на manager, значит был вызван return_to_manager
if self.manager_agent.active_agent_id == "manager":
    # Запускаем менеджера с тем же интерфейсом, что использовался ранее
    await self.manager_agent.run(
        messages=self.manager_agent.history.messages,
        model=self.model, 
        # ... остальные параметры ...
    )
```

## Преимущества рекомендуемого решения

1. **Естественная интеграция** - использует существующий поток выполнения и стиль кода
2. **Избегает вложенного выполнения** - не создает дополнительных уровней ожидания
3. **Сохраняет блокирующую модель** - сохраняет однородность кода
4. **Предсказуемый результат** - четкая последовательность действий
5. **Минимальные изменения** - модификация только нескольких методов
6. **Без параллельного выполнения** - избегает проблем с управлением параллельными задачами

## План реализации

1. Модифицировать `Agent.run()` для детектирования вызова инструмента `return_to_manager` и досрочного выхода
2. Добавить в `AgentTool._call()` код для запуска менеджера, если был вызван `return_to_manager`
3. Обеспечить добавление сообщения с результатом в историю менеджера
4. Добавить информативное логирование
5. Обработать ошибки при запуске менеджера

Такое решение обеспечит плавный переход от специалиста к менеджеру после вызова `return_to_manager`, сохраняя при этом существующий паттерн блокирующего вызова между агентами. 